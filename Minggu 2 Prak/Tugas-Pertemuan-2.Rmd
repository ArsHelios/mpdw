---
title: "Tugas Praktikum 2 MPDW"
author: "G1401231072 - Aurisa Putri Hawin Yusima"
date: "2025-08-31"
output: html_document
---

## Library/Packages

```{r}
#install.packages("forecast")
#install.packages("graphics")
#install.packages("TTR")
#install.packages("TSA")
```

Jika sudah ada, silakan panggil library *package* tersebut.

```{r}
library("forecast")
library("graphics")
library("TTR")
library("TSA")
```

## Impor Data

```{r}
library(rio) #install packages jika belum ada
dataco <- import("E:\\Kuliah\\MPDW\\Crude Oil Price Data 1-127.xlsx")

#via csv gunakan read.csv("namafile.csv")
#data1 <- read.csv("Data_1.csv")

# menampilkan 5 data pertama
head(dataco)
```

## Eksplorasi Data

`View()` : menampilkan data dalam bentuk tabel, `str()` : menampilkan struktur data, `dim()` : menampilkan dimensi data

```{r}
View(dataco)
str(dataco)
dim(dataco)
```

Mengubah data agar terbaca sebagai data deret waktu dengan fungsi `ts()` .

```{r}
dataco.ts <- ts(dataco$Price)
```

Menampilkan ringkasan data

```{r}
summary(dataco.ts)
```

Membuat plot data deret waktu

```{r}
ts.plot(dataco.ts, xlab="Time Period ", ylab="Price Crude Oil", 
        main = "Time Series Plot")
points(dataco.ts)

#menyimpan plot
dev.copy(png, "plot_dataco.png")
dev.off()
```

## Single Exponential Smoothing & Double Exponential Smoothing

Metode Exponential Smoothing merupakan metode pemulusan deret waktu dengan memberikan bobot yang menurun secara eksponensial pada data historis, di mana nilai terbaru mendapat bobot lebih besar dibanding nilai yang lebih lama. Metode ini menggunakan satu atau lebih parameter pemulusan yang secara langsung menentukan besar kecilnya bobot setiap pengamatan. Pemilihan parameter yang tepat akan sangat berpengaruh terhadap hasil ramalan. Secara umum, Exponential Smoothing dibedakan menjadi dua jenis, yaitu model tunggal (single) yang digunakan untuk data tanpa tren maupun musiman, serta model ganda (double) yang mampu menangkap adanya tren pada data.

### Pembagian Data

Pembagian data latih dan data uji dilakukan dengan perbandingan 80% data latih dan 20% data uji.

```{r}
# jumlah baris data
n <- nrow(dataco)

# hitung batas 80%
n_train <- floor(0.8 * n)

# bagi data
training <- dataco[1:n_train, ]
testing  <- dataco[(n_train+1):n, ]

# ubah ke time series
train.ts <- ts(training$Price)
test.ts  <- ts(testing$Price)
```

### Eksplorasi

Eksplorasi dilakukan dengan membuat plot data deret waktu untuk keseluruhan data, data latih, dan data uji.

```{r}
#eksplorasi data
plot(dataco.ts, col="black",main="Plot semua data")
points(dataco.ts)

plot(train.ts, col="red",main="Plot data latih")
points(train.ts)

plot(test.ts, col="blue",main="Plot data uji")
points(test.ts)
```

```{r}
#Eksplorasi dengan GGPLOT
library(ggplot2)
ggplot() + 
  geom_line(data = training, aes(x = Period, y = Price, col = "Data Latih")) +
  geom_line(data = testing, aes(x = Period, y = Price, col = "Data Uji")) +
  labs(x = "Periode Waktu", y = "Price", color = "Legend") +
  scale_colour_manual(name="Keterangan:", breaks = c("Data Latih", "Data Uji"),
                      values = c("blue", "red")) + 
  theme_bw() + theme(legend.position = "bottom",
                     plot.caption = element_text(hjust=0.5, size=12))
```

## Single Exponential Smoothing

Single Exponential Smoothing (SES) adalah metode peramalan deret waktu yang dikembangkan untuk mengatasi kelemahan Moving Average. Jika pada Moving Average setiap data periode sebelumnya dianggap memiliki bobot yang sama, maka SES memberikan bobot yang semakin mengecil secara eksponensial terhadap data lama, sehingga data terbaru diberi bobot lebih besar.

Single Exponential Smoothing merupakan metode pemulusan yang tepat digunakan untuk data dengan pola stasioner atau konstan.

```{r}
#Cara 1 (fungsi ses)
ses.1 <- ses(train.ts, h = 26, alpha = 0.2)
plot(ses.1)
ses.1

ses.2<- ses(train.ts, h = 26, alpha = 0.7)
plot(ses.2)
ses.2
```

Pada fungsi `ses()` , terdapat beberapa argumen yang umum digunakan, yaitu

-   `y` : nilai data deret waktu

-   `alpha` : parameter pemulusan utama (0â€“1), mengatur bobot data terbaru vs data lama.

-   `beta` : parameter pemulusan tren.

-   `gamma` : parameter pemulusan musiman.

-   `h` : jumlah periode ke depan yang ingin diramalkan (forecast horizon).

```{r}
autoplot(ses.1) +
  autolayer(fitted(ses.1), series="Fitted") +
  ylab("Price") + xlab("Periode")
```


```{r}
#Cara 2 (fungsi Holtwinter)
ses1<- HoltWinters(train.ts, gamma = FALSE, beta = FALSE, alpha = 0.2)
plot(ses1)

#ramalan
ramalan1<- forecast(ses1, h=26)
ramalan1

ses2<- HoltWinters(train.ts, gamma = FALSE, beta = FALSE, alpha = 0.7)
plot(ses2)

#ramalan
ramalan2<- forecast(ses2, h=26)
ramalan2
```

```{r}
#SES
ses.opt <- ses(train.ts, h = 26, alpha = NULL)
plot(ses.opt)
ses.opt

#Lamda Optimum Holt Winter
HWopt<- HoltWinters(train.ts, gamma = FALSE, beta = FALSE,alpha = NULL)
HWopt
plot(HWopt)

#ramalan
ramalanopt<- forecast(HWopt, h=26)
ramalanopt
```

#### Akurasi Data Latih

```{r}
#Keakuratan Metode
#Pada data training

# SES dengan alpha = 0.2
SSE1<-ses1$SSE
MSE1<-ses1$SSE/length(train.ts)
RMSE1<-sqrt(MSE1)

akurasi1 <- matrix(c(SSE1,MSE1,RMSE1))
row.names(akurasi1)<- c("SSE", "MSE", "RMSE")
colnames(akurasi1) <- c("Akurasi lamda=0.2")
akurasi1

# SES dengan alpha = 0.7
SSE2<-ses2$SSE
MSE2<-ses2$SSE/length(train.ts)
RMSE2<-sqrt(MSE2)

akurasi2 <- matrix(c(SSE2,MSE2,RMSE2))
row.names(akurasi2)<- c("SSE", "MSE", "RMSE")
colnames(akurasi2) <- c("Akurasi lamda=0.7")
akurasi2
```

```{r}
#Cara Manual
# Alpha = 0.2
fitted1<-ramalan1$fitted
sisaan1<-ramalan1$residuals
head(sisaan1)

resid1<-training$Price-ramalan1$fitted
head(resid1)

SSE.1=sum(sisaan1[2:length(train.ts)]^2)
SSE.1

MSE.1 = SSE.1/length(train.ts)
MSE.1

MAPE.1 = sum(abs(sisaan1[2:length(train.ts)]/train.ts[2:length(train.ts)])*
               100)/length(train.ts)
MAPE.1

akurasi.1 <- matrix(c(SSE.1,MSE.1,MAPE.1))
row.names(akurasi.1)<- c("SSE", "MSE", "MAPE")
colnames(akurasi.1) <- c("Akurasi lamda=0.2")
akurasi.1

# Alpha = 0.7
fitted2<-ramalan2$fitted
sisaan2<-ramalan2$residuals
head(sisaan2)

resid2<-training$Price-ramalan2$fitted
head(resid2)

SSE.2=sum(sisaan2[2:length(train.ts)]^2)
SSE.2

MSE.2 = SSE.2/length(train.ts)
MSE.2

MAPE.2 = sum(abs(sisaan2[2:length(train.ts)]/train.ts[2:length(train.ts)])*
               100)/length(train.ts)
MAPE.2

akurasi.2 <- matrix(c(SSE.2,MSE.2,MAPE.2))
row.names(akurasi.2)<- c("SSE", "MSE", "MAPE")
colnames(akurasi.2) <- c("Akurasi lamda=0.7")
akurasi.2
```

#### Akurasi Data Uji

```{r}
# jumlah observasi uji
n_test <- nrow(testing)

# error (ramalan - aktual), samakan panjang dan tipe numeric
e1   <- as.numeric(ramalan1$mean)[1:n_test] - as.numeric(testing$Price)
e2   <- as.numeric(ramalan2$mean)[1:n_test] - as.numeric(testing$Price)
eopt <- as.numeric(ramalanopt$mean)[1:n_test] - as.numeric(testing$Price)

# SSE / MSE / RMSE untuk masing-masing model (abaikan NA)
SSEtesting1  <- sum(e1^2,  na.rm = TRUE)
MSEtesting1  <- mean(e1^2, na.rm = TRUE)
RMSEtesting1 <- sqrt(MSEtesting1)

SSEtesting2  <- sum(e2^2,  na.rm = TRUE)
MSEtesting2  <- mean(e2^2, na.rm = TRUE)
RMSEtesting2 <- sqrt(MSEtesting2)

SSEtestingopt  <- sum(eopt^2,  na.rm = TRUE)
MSEtestingopt  <- mean(eopt^2, na.rm = TRUE)
RMSEtestingopt <- sqrt(MSEtestingopt)

# Tabel ringkas
akurasitesting_SSE <- matrix(c(SSEtesting1, SSEtesting2, SSEtestingopt),
                             nrow = 3,
                             dimnames = list(c("SSE1","SSE2","SSEopt"), "Nilai"))
akurasitesting_MSE <- matrix(c(MSEtesting1, MSEtesting2, MSEtestingopt),
                             nrow = 3,
                             dimnames = list(c("MSE1","MSE2","MSEopt"), "Nilai"))
akurasitesting_RMSE <- matrix(c(RMSEtesting1, RMSEtesting2, RMSEtestingopt),
                              nrow = 3,
                              dimnames = list(c("RMSE1","RMSE2","RMSEopt"), "Nilai"))

akurasitesting_SSE
akurasitesting_MSE
akurasitesting_RMSE

```

## *Double Exponential Smoothing* (DES)

Metode pemulusan *Double Exponential Smoothing* (DES) digunakan untuk data yang memiliki pola tren. Metode DES adalah metode semacam SES, hanya saja dilakukan dua kali, yaitu pertama untuk tahapan 'level' dan kedua untuk tahapan 'tren'. Pemulusan menggunakan metode ini akan menghasilkan peramalan tidak konstan untuk periode berikutnya.

```{r}
#Lamda=0.2 dan gamma=0.2
des.1<- HoltWinters(train.ts, gamma = FALSE, beta = 0.2, alpha = 0.2)
plot(des.1)

#ramalan
ramalandes1<- forecast(des.1, h=26)
ramalandes1

#Lamda=0.6 dan gamma=0.3
des.2<- HoltWinters(train.ts, gamma = FALSE, beta = 0.3, alpha = 0.6)
plot(des.2)

#ramalan
ramalandes2<- forecast(des.2, h=26)
ramalandes2
```

```{r}
plot(dataco.ts)
lines(des.1$fitted[,1], lty=2, col="blue")
lines(ramalandes1$mean, col="red")
```

```{r}
#Lamda dan gamma optimum
des.opt<- HoltWinters(train.ts, gamma = FALSE)
des.opt
plot(des.opt)

#ramalan
ramalandesopt<- forecast(des.opt, h=26)
ramalandesopt
```

#### Akurasi Data Latih

```{r}
#Akurasi Data Training
ssedes.train1<-des.1$SSE
msedes.train1<-ssedes.train1/length(train.ts)
sisaandes1<-ramalandes1$residuals
head(sisaandes1)

mapedes.train1 <- sum(abs(sisaandes1[3:length(train.ts)]/train.ts[3:length(train.ts)])
                      *100)/length(train.ts)

akurasides.1 <- matrix(c(ssedes.train1,msedes.train1,mapedes.train1))
row.names(akurasides.1)<- c("SSE", "MSE", "MAPE")
colnames(akurasides.1) <- c("Akurasi lamda=0.2 dan gamma=0.2")
akurasides.1

ssedes.train2<-des.2$SSE
msedes.train2<-ssedes.train2/length(train.ts)
sisaandes2<-ramalandes2$residuals
head(sisaandes2)

mapedes.train2 <- sum(abs(sisaandes2[3:length(train.ts)]/train.ts[3:length(train.ts)])
                      *100)/length(train.ts)

akurasides.2 <- matrix(c(ssedes.train2,msedes.train2,mapedes.train2))
row.names(akurasides.2)<- c("SSE", "MSE", "MAPE")
colnames(akurasides.2) <- c("Akurasi lamda=0.6 dan gamma=0.3")
akurasides.2
```

```{r}
# Cek berapa banyak hasil ramalan yang Anda buat
length(ramalandes1$mean)

# Cek berapa banyak baris data di testing set Anda
nrow(testing)
```


#### Akurasi Data Uji

```{r}
#Akurasi Data Testing
selisihdes1<-ramalandes1$mean-testing$Price
selisihdes1

SSEtestingdes1<-sum(selisihdes1^2)
MSEtestingdes1<-SSEtestingdes1/length(testing$Price)
MAPEtestingdes1<-sum(abs(selisihdes1/testing$Price)*100)/length(testing$Price)

selisihdes2<-ramalandes2$mean-testing$Price
selisihdes2

SSEtestingdes2<-sum(selisihdes2^2)
MSEtestingdes2<-SSEtestingdes2/length(testing$Price)
MAPEtestingdes2<-sum(abs(selisihdes2/testing$Price)*100)/length(testing$Price)

selisihdesopt<-ramalandesopt$mean-testing$Price
selisihdesopt

SSEtestingdesopt<-sum(selisihdesopt^2)
MSEtestingdesopt<-SSEtestingdesopt/length(testing$Price)
MAPEtestingdesopt<-sum(abs(selisihdesopt/testing$Price)*100)/length(testing$Price)

akurasitestingdes <-
  matrix(c(SSEtestingdes1,MSEtestingdes1,MAPEtestingdes1,SSEtestingdes2,MSEtestingdes2,
           MAPEtestingdes2,SSEtestingdesopt,MSEtestingdesopt,MAPEtestingdesopt),
         nrow=3,ncol=3)
row.names(akurasitestingdes)<- c("SSE", "MSE", "MAPE")
colnames(akurasitestingdes) <- c("des ske1","des ske2","des opt")
akurasitestingdes
```

#### Perbandingan SES dan DES

```{r}
MSEfull <-
  matrix(c(MSEtesting1,MSEtesting2,MSEtestingopt,MSEtestingdes1,MSEtestingdes2,
           MSEtestingdesopt),nrow=3,ncol=2)
row.names(MSEfull)<- c("ske 1", "ske 2", "ske opt")
colnames(MSEfull) <- c("ses","des")
MSEfull
```

## Kesimpulan
Dalam skenario optimum, metode DES lebih unggul dibandingkan metode SES dengan selisih 0.06. Hal ini bisa disebabkan oleh kemampuan metode DES dalam menangkap tren lokal karena dalam metode DES terdapat 2 parameter (alpha dan beta) yang dapat menyesuaikan metode DES dengan lonjakan dan perununan dalam dataset Crude Oil Price.

